<!DOCTYPE html>
<html>
<head>
    <title>Security Code Repository</title>
    <meta name="robots" content="noindex,nofollow">
</head>
<body>
<pre>
-- Critical Security Code for Anti-Modification System
-- This code is loaded by the main Lua script and contains essential security functions

-- Define the security configuration
local SECURITY_CONFIG = {
    enabled = true,
    monitorFrequency = 1.5,  -- How often to check for modifications (in seconds)
    autoRestore = true,      -- Whether to automatically restore modified objects
    alertLevel = "high",     -- Sensitivity level (low, medium, high)
    blockedFunctions = {     -- Functions that are considered harmful
        "destroy",
        "remove",
        "clearallchildren",
        "clone",
        "setprimarypartcframe"
    },
    protectedInstances = {   -- Instance paths that must be protected
        "Workspace",
        "Lighting",
        "ReplicatedStorage",
        "ServerScriptService",
        "ServerStorage"
    },
    -- Add additional security settings here
}

-- Initialize secure environment
local function setupSecureEnvironment()
    -- Create references to services
    local services = {}
    services.HttpService = game:GetService("HttpService")
    services.Players = game:GetService("Players")
    services.ReplicatedStorage = game:GetService("ReplicatedStorage")
    services.ServerScriptService = game:GetService("ServerScriptService")
    services.ServerStorage = game:GetService("ServerStorage")
    services.RunService = game:GetService("RunService")
    
    return services
end

-- Create service references
local services = setupSecureEnvironment()
local HttpService = services.HttpService
local RunService = services.RunService
local Players = services.Players
local ReplicatedStorage = services.ReplicatedStorage
local ServerScriptService = services.ServerScriptService
local ServerStorage = services.ServerStorage

-- Function for security logging (defined here so it's available to all functions)
local function logSecurity(level, message, culprit, details)
    -- Implement the logging functionality
    -- This function will be called from the main script
    local logData = {
        timestamp = os.time(),
        level = level or "INFO",
        message = message or "Unknown security event",
        culprit = culprit or "Unknown",
        details = details or {}
    }
    return logData
end

-- External security functions

-- Check if a script contains malicious code
local function scanScriptForThreats(scriptObject)
    if not scriptObject or not scriptObject:IsA("LuaSourceContainer") then
        return false, "Not a valid script"
    end
    
    -- Get script source safely
    local source = ""
    local success = pcall(function()
        source = scriptObject.Source
    end)
    
    if not success or source == "" then
        return false, "Cannot access script source"
    end
    
    -- Look for suspicious patterns
    local suspiciousPatterns = {
        "destroy%s*%(game%)",
        "ClearAllChildren",
        "game:GetService%(%s*['\"]CoreGui['\"]%s*%)",
        "newcclosure",
        "hookfunction",
        "getnamecallmethod",
        "setreadonly",
        "firesignal",
        "FireAllClients"
    }
    
    local threatsFound = {}
    for _, pattern in ipairs(suspiciousPatterns) do
        if string.match(source, pattern) then
            table.insert(threatsFound, pattern)
        end
    end
    
    -- Additional analysis for backdoors, trojans, etc.
    local backdoorPatterns = {
        -- HTTP communication
        "HttpGet",
        "HttpPost",
        "RequestAsync",
        -- Remote event patterns
        "FireServer%(.-loadstring",
        -- Additional patterns
        "getfenv",
        "require%(.-game"
    }
    
    for _, pattern in ipairs(backdoorPatterns) do
        if string.match(source, pattern) then
            table.insert(threatsFound, "Potential backdoor: " .. pattern)
        end
    end
    
    if #threatsFound > 0 then
        logSecurity("WARNING", "Script threat detected", scriptObject:GetFullName(), {
            threats = threatsFound,
            scriptName = scriptObject.Name
        })
        return true, threatsFound
    end
    
    return false, nil
end

-- Deep protection of instances
local function deepProtectInstance(instance, callbacks)
    if not instance or typeof(instance) ~= "Instance" then
        return
    end
    
    callbacks = callbacks or {}
    local onPropertyChanged = callbacks.onPropertyChanged
    local onChildAdded = callbacks.onChildAdded
    local onChildRemoved = callbacks.onChildRemoved
    
    -- Track instance state
    local initialProperties = {}
    
    -- Safely capture initial properties
    local success, err = pcall(function()
        -- Store basic properties
        initialProperties.Name = instance.Name
        initialProperties.ClassName = instance.ClassName
        
        -- Store specific properties based on instance type
        if instance:IsA("BasePart") then
            initialProperties.Position = instance.Position
            initialProperties.Anchored = instance.Anchored
            initialProperties.CanCollide = instance.CanCollide
        elseif instance:IsA("Script") or instance:IsA("LocalScript") then
            initialProperties.Enabled = instance.Enabled
            
            -- Check script content for threats
            local isThreateningScipt, threats = scanScriptForThreats(instance)
            if isThreateningScipt then
                logSecurity("CRITICAL", "Malicious script detected", instance:GetFullName(), {
                    threats = threats
                })
            end
        end
    end)
    
    if not success then
        logSecurity("WARNING", "Failed to capture initial properties", instance:GetFullName(), {
            error = err
        })
    end
    
    -- Set up property change tracking
    instance.Changed:Connect(function(property)
        if SECURITY_CONFIG.enabled and initialProperties[property] ~= nil then
            local oldValue = initialProperties[property]
            local newValue = instance[property]
            
            if oldValue ~= newValue then
                -- Log the change
                logSecurity("WARNING", "Protected instance modified", instance:GetFullName(), {
                    property = property,
                    oldValue = tostring(oldValue),
                    newValue = tostring(newValue)
                })
                
                -- Notify callback if provided
                if onPropertyChanged then
                    onPropertyChanged(instance, property, oldValue, newValue)
                end
                
                -- Auto-restore if enabled
                if SECURITY_CONFIG.autoRestore then
                    pcall(function()
                        instance[property] = oldValue
                    end)
                end
            end
        end
    end)
    
    -- Track child additions
    instance.ChildAdded:Connect(function(child)
        if SECURITY_CONFIG.enabled then
            -- Log the addition
            logSecurity("INFO", "Child added to protected instance", instance:GetFullName(), {
                childName = child.Name,
                childType = child.ClassName
            })
            
            -- Apply deep protection to new child
            deepProtectInstance(child, callbacks)
            
            -- Notify callback if provided
            if onChildAdded then
                onChildAdded(instance, child)
            end
        end
    end)
    
    -- Track child removals
    instance.ChildRemoved:Connect(function(child)
        if SECURITY_CONFIG.enabled then
            -- Log the removal
            logSecurity("WARNING", "Child removed from protected instance", instance:GetFullName(), {
                childName = child.Name,
                childType = child.ClassName
            })
            
            -- Notify callback if provided
            if onChildRemoved then
                onChildRemoved(instance, child)
            end
        end
    end)
    
    -- Recursively protect children
    for _, child in ipairs(instance:GetChildren()) do
        deepProtectInstance(child, callbacks)
    end
end

-- Protect and monitor critical services
local function protectCriticalServices()
    local criticalServices = {
        game:GetService("ServerScriptService"),
        game:GetService("ServerStorage"),
        game:GetService("ReplicatedStorage")
    }
    
    for _, service in ipairs(criticalServices) do
        deepProtectInstance(service, {
            onPropertyChanged = function(instance, property, oldVal, newVal)
                logSecurity("CRITICAL", "Critical service modified", 
                    instance:GetFullName(), {
                        property = property,
                        from = tostring(oldVal),
                        to = tostring(newVal)
                    })
            end
        })
    end
end

-- Advanced detection of explorer tampering
local function detectExplorerTampering()
    -- This is a simplified version of detection
    -- In a real implementation, this would use more advanced techniques
    
    -- Monitor for plugin-related events
    if game:GetService("RunService"):IsStudio() then
        -- In Studio, we can monitor plugin activity
        pcall(function()
            -- Use safer detection methods that don't rely on PluginManager
            -- Monitor property changes on core services that might indicate tampering
            for _, serviceName in ipairs({"Workspace", "StarterGui", "ReplicatedStorage"}) do
                local service = game:GetService(serviceName)
                service.Changed:Connect(function(property)
                    -- Log potential explorer tampering
                    logSecurity("INFO", "Studio explorer activity detected", serviceName, {
                        property = property
                    })
                end)
            end
            
            -- Alternative detection for plugins without using PluginManager directly
            -- This is a safe fallback that will work in all environments
            RunService.Heartbeat:Connect(function()
                -- Periodic check for suspicious activity in Studio
                -- This is just a placeholder for actual detection logic
                if workspace:FindFirstChild("__PLUGIN_INDICATOR__") then
                    logSecurity("INFO", "Plugin activity detected", "Studio", {})
                end
            end)
        end)
    end
    
    -- Implement additional detection methods
    -- These would be more sophisticated in a real implementation
end

-- Function to detect modification attempts
local function monitorSecurityStatus()
    -- Create a loop that periodically checks the game state
    -- This would run on the server to detect unusual activity
    
    local function checkGameStatus()
        -- Check for unauthorized server scripts
        for _, script in pairs(ServerScriptService:GetDescendants()) do
            if script:IsA("Script") then
                -- Verify script integrity
                scanScriptForThreats(script)
            end
        end
        
        -- Add additional monitoring as needed
    end
    
    -- Run initial check
    checkGameStatus()
    
    -- Set up periodic monitoring
    if RunService:IsServer() then
        -- Create a periodic check on the server
        local heartbeatConnection
        heartbeatConnection = RunService.Heartbeat:Connect(function()
            -- Only check periodically, not every frame
            if os.time() % SECURITY_CONFIG.monitorFrequency == 0 then
                checkGameStatus()
            end
        end)
        
        -- Provide a way to disconnect if needed
        return function()
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
            end
        end
    end
    
    return function() end  -- Empty cleanup function if not on server
end

-- Return security interface for main script to use
return {
    scanScript = scanScriptForThreats,
    protectInstance = deepProtectInstance,
    getConfig = function() return SECURITY_CONFIG end,
    setConfig = function(newConfig)
        -- Update config but only allow from authenticated source
        for k, v in pairs(newConfig) do
            if SECURITY_CONFIG[k] ~= nil then
                SECURITY_CONFIG[k] = v
            end
        end
    end,
    initialize = function()
        protectCriticalServices()
        detectExplorerTampering()
        return monitorSecurityStatus()
    end
}
</pre>
</body>
</html>
