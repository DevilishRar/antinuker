<!DOCTYPE html>
<html>
<head>
    <title>Security Code Repository</title>
    <meta name="robots" content="noindex,nofollow">
</head>
<body>
<pre>
-- Critical Security Code for Anti-Modification System
-- Enhanced Security Module with comprehensive anti-nuking protection

-- Define the security configuration
local SECURITY_CONFIG = {
    enabled = true,
    monitorFrequency = 1.5,  -- How often to check for modifications (in seconds)
    autoRestore = true,      -- Whether to automatically restore modified objects
    alertLevel = "high",     -- Sensitivity level (low, medium, high)
    
    -- Script security settings
    scriptSecurity = {
        autoDeleteMalicious = true,      -- Automatically delete malicious scripts
        scanExistingOnStart = true,      -- Scan all existing scripts when security starts
        maxScriptsPerMinute = 10,        -- Maximum scripts created per minute (per player)
        blockRequireCalls = true,        -- Block unauthorized require() calls
        blockNootNoot = true,            -- Block noot noot crash scripts
        whitelistedCreators = {          -- Users allowed to create/modify scripts
            ["DevilishRak_s"] = true
        }
    },
    
    -- Audio security settings
    audioSecurity = {
        enforceVolumeCap = true,         -- Enforce maximum volume for sounds
        maxVolume = 0.7,                -- Maximum allowed volume (0-1)
        blockEarRape = true,            -- Block extremely loud sounds
        volumeCapEnabled = true,        -- Enable volume capping for all sounds
        scanExistingOnStart = true       -- Scan existing sounds on startup
    },
    
    -- GUI security settings
    guiSecurity = {
        monitorPlayerGui = true,         -- Monitor PlayerGui for unauthorized additions
        allowNativeGuis = true,          -- Allow Roblox native GUIs
        logNewGuiAdditions = true,       -- Log all new GUI additions
        blockFullScreenGuis = true,      -- Block unauthorized full-screen GUIs
        blockScreenCoveringGuis = true    -- Block GUIs that cover the entire screen
    },
    
    -- Harmful patterns and functions
    blockedFunctions = {     -- Functions that are considered harmful
        "destroy",
        "remove",
        "clearallchildren",
        "clone",
        "setprimarypartcframe",
        "breakjoints",
        "kick"
    },
    
    -- Malicious code detection patterns
    maliciousPatterns = {
        "while%s+true",                 -- Infinite loops
        "for%s+i%s*=%s*1,%s*9999999",   -- Very long loops
        "noot%s*noot",                  -- Noot noot crash script
        "game:Destroy",                 -- Game destruction
        "ClearAllChildren",             -- Mass object removal
        "while%s+wait%(.-%)%s+do",       -- While-wait loops (potentially infinite)
        "while%s+true%s+do",            -- While true loops
        "for%s+i%s*=%s*1,%s*math%.huge", -- Infinite for loops
        "FireAllClients",               -- Mass remote event firing
        "SetCore",                      -- GUI core manipulation
        "RenderStepped:Connect",        -- High-frequency connections
        "Players:GetPlayers%(%)[^:]+ForEach", -- Mass player operations
        "workspace:GetDescendants%(%)"   -- Mass workspace operations
    },
    
    protectedInstances = {   -- Instance paths that must be protected
        "Workspace",
        "Lighting",
        "ReplicatedStorage",
        "ServerScriptService",
        "ServerStorage",
        "StarterGui",
        "StarterPack",
        "StarterPlayer",
        "Teams",
        "SoundService"
    }
}

-- Initialize secure environment
local function setupSecureEnvironment()
    -- Create references to services
    local services = {}
    services.HttpService = game:GetService("HttpService")
    services.Players = game:GetService("Players")
    services.ReplicatedStorage = game:GetService("ReplicatedStorage")
    services.ServerScriptService = game:GetService("ServerScriptService")
    services.ServerStorage = game:GetService("ServerStorage")
    services.RunService = game:GetService("RunService")
    
    return services
end

-- Create service references
local services = setupSecureEnvironment()
local HttpService = services.HttpService
local RunService = services.RunService
local Players = services.Players
local ReplicatedStorage = services.ReplicatedStorage
local ServerScriptService = services.ServerScriptService
local ServerStorage = services.ServerStorage

-- Function for security logging (defined here so it's available to all functions)
local function logSecurity(level, message, culprit, details)
    -- Implement the logging functionality
    -- This function will be called from the main script
    local logData = {
        timestamp = os.time(),
        level = level or "INFO",
        message = message or "Unknown security event",
        culprit = culprit or "Unknown",
        details = details or {}
    }
    return logData
end

-- Handle malicious script detection and removal
local function handleMaliciousScript(scriptObject, threats)
    if not scriptObject or not SECURITY_CONFIG.scriptSecurity.autoDeleteMalicious then
        return
    end
    
    -- Get script creator if possible
    local creator = nil
    pcall(function() 
        creator = scriptObject:FindFirstAncestorOfClass("Player") 
    end)
    
    -- Check if creator is whitelisted before taking action
    local creatorName = creator and creator.Name or "Unknown"
    if SECURITY_CONFIG.scriptSecurity.whitelistedCreators[creatorName] then
        logSecurity("WARNING", "Potentially malicious script created by whitelisted user", creatorName, {
            scriptPath = scriptObject:GetFullName(),
            threats = threats
        })
        return
    end
    
    -- Take action on malicious script
    pcall(function()
        -- Disable first to prevent any execution
        if scriptObject:IsA("LuaSourceContainer") and 
           (scriptObject:IsA("LocalScript") or scriptObject:IsA("Script")) then
            scriptObject.Disabled = true
        end
        
        -- Delete the script
        scriptObject:Destroy()
        
        logSecurity("CRITICAL", "Automatically deleted malicious script", scriptObject:GetFullName(), {
            creator = creatorName,
            action = "Script deleted",
            threats = threats
        })
    end)
end

-- Check if a script contains malicious code
local function scanScriptForThreats(scriptObject)
    if not scriptObject or not scriptObject:IsA("LuaSourceContainer") then
        return false, "Not a valid script"
    end
    
    -- Get script source safely
    local source = ""
    local success = pcall(function()
        source = scriptObject.Source
    end)
    
    if not success or source == "" then
        return false, "Cannot access script source"
    end
    
    -- Check for noot noot crash scripts and other common crash patterns
    if SECURITY_CONFIG.scriptSecurity.blockNootNoot then
        -- Check for direct noot noot pattern
        if string.match(string.lower(source), "noot%s*noot") then
            return true, {"Contains noot noot crash script pattern"}
        end
        
        -- Check for common crash patterns
        local crashPatterns = {
            "while%s+true",                 -- Infinite loops with no wait
            "while%s+not%s+nil",            -- Another infinite loop
            "for%s+i%s*=%s*1,%s*9999999",   -- Extremely long loops
            "for%s+i%s*=%s*1,%s*math%.huge", -- Infinite for loops
        }
        
        for _, pattern in ipairs(crashPatterns) do
            -- Look for the pattern combined with no wait() call nearby
            if string.match(source, pattern) and not string.match(source, pattern .. ".-wait%(%) *") then
                return true, {"Server crash pattern detected: " .. pattern}
            end
        end
    end
    
    -- Look for all configured malicious patterns from config
    local threatsFound = {}
    for _, pattern in ipairs(SECURITY_CONFIG.maliciousPatterns) do
        if string.match(source, pattern) then
            table.insert(threatsFound, "Malicious pattern: " .. pattern)
        end
    end
    
    -- Check for suspicious service and method usage
    local servicePatterns = {
        -- Destruction patterns
        "destroy%s*%(game%)",              -- Trying to destroy game
        "game:GetService%(\"Players\"%):ClearAllChildren", -- Removing all players
        "workspace:ClearAllChildren",     -- Clearing workspace
        
        -- Security bypass patterns
        "newcclosure",                   -- Exploiter function
        "hookfunction",                  -- Function hooking
        "getnamecallmethod",             -- Method name spoofing
        "setreadonly",                   -- Modify readonly tables
        "firesignal",                    -- Fire signals manually
        
        -- Remote abuse patterns
        "FireAllClients",                -- Mass remote firing
        "FireServer%(.-loadstring",       -- Remote code execution
        
        -- Backdoor patterns
        "HttpGet",                       -- External HTTP requests
        "HttpPost",                      -- External HTTP POST requests
        "RequestAsync",                  -- Async HTTP requests
        "getfenv",                       -- Environment access
        "require%(.-game"                 -- Requiring from game
    }
    
    for _, pattern in ipairs(servicePatterns) do
        if string.match(source, pattern) then
            table.insert(threatsFound, "Suspicious API usage: " .. pattern)
        end
    end
    
    -- Special check for require() abuse
    if SECURITY_CONFIG.scriptSecurity.blockRequireCalls and 
       string.match(source, "require%(.-%)%s*%(%(?") then -- Looking for require() calls that immediately execute
        table.insert(threatsFound, "Immediate execution of require() result")
    end
    
    if #threatsFound > 0 then
        logSecurity("WARNING", "Script threat detected", scriptObject:GetFullName(), {
            threats = threatsFound,
            scriptName = scriptObject.Name
        })
        return true, threatsFound
    end
    
    return false, nil
end

-- Deep protection of instances
local function deepProtectInstance(instance, callbacks)
    if not instance or typeof(instance) ~= "Instance" then
        return
    end
    
    callbacks = callbacks or {}
    local onPropertyChanged = callbacks.onPropertyChanged
    local onChildAdded = callbacks.onChildAdded
    local onChildRemoved = callbacks.onChildRemoved
    
    -- Track instance state
    local initialProperties = {}
    
    -- Safely capture initial properties
    local success, err = pcall(function()
        -- Store basic properties
        initialProperties.Name = instance.Name
        initialProperties.ClassName = instance.ClassName
        
        -- Store specific properties based on instance type
        if instance:IsA("BasePart") then
            initialProperties.Position = instance.Position
            initialProperties.Anchored = instance.Anchored
            initialProperties.CanCollide = instance.CanCollide
        elseif instance:IsA("Script") or instance:IsA("LocalScript") then
            initialProperties.Enabled = instance.Enabled
            
            -- Check script content for threats
            local isThreateningScipt, threats = scanScriptForThreats(instance)
            if isThreateningScipt then
                logSecurity("CRITICAL", "Malicious script detected", instance:GetFullName(), {
                    threats = threats
                })
            end
        end
    end)
    
    if not success then
        logSecurity("WARNING", "Failed to capture initial properties", instance:GetFullName(), {
            error = err
        })
    end
    
    -- Set up property change tracking
    instance.Changed:Connect(function(property)
        if SECURITY_CONFIG.enabled and initialProperties[property] ~= nil then
            local oldValue = initialProperties[property]
            local newValue = instance[property]
            
            if oldValue ~= newValue then
                -- Log the change
                logSecurity("WARNING", "Protected instance modified", instance:GetFullName(), {
                    property = property,
                    oldValue = tostring(oldValue),
                    newValue = tostring(newValue)
                })
                
                -- Notify callback if provided
                if onPropertyChanged then
                    onPropertyChanged(instance, property, oldValue, newValue)
                end
                
                -- Auto-restore if enabled
                if SECURITY_CONFIG.autoRestore then
                    pcall(function()
                        instance[property] = oldValue
                    end)
                end
            end
        end
    end)
    
    -- Track child additions
    instance.ChildAdded:Connect(function(child)
        if SECURITY_CONFIG.enabled then
            -- Log the addition
            logSecurity("INFO", "Child added to protected instance", instance:GetFullName(), {
                childName = child.Name,
                childType = child.ClassName
            })
            
            -- Apply deep protection to new child
            deepProtectInstance(child, callbacks)
            
            -- Notify callback if provided
            if onChildAdded then
                onChildAdded(instance, child)
            end
        end
    end)
    
    -- Track child removals
    instance.ChildRemoved:Connect(function(child)
        if SECURITY_CONFIG.enabled then
            -- Log the removal
            logSecurity("WARNING", "Child removed from protected instance", instance:GetFullName(), {
                childName = child.Name,
                childType = child.ClassName
            })
            
            -- Notify callback if provided
            if onChildRemoved then
                onChildRemoved(instance, child)
            end
        end
    end)
    
    -- Recursively protect children
    for _, child in ipairs(instance:GetChildren()) do
        deepProtectInstance(child, callbacks)
    end
end

-- Protect and monitor critical services
local function protectCriticalServices()
    local criticalServices = {
        game:GetService("ServerScriptService"),
        game:GetService("ServerStorage"),
        game:GetService("ReplicatedStorage")
    }
    
    for _, service in ipairs(criticalServices) do
        deepProtectInstance(service, {
            onPropertyChanged = function(instance, property, oldVal, newVal)
                logSecurity("CRITICAL", "Critical service modified", 
                    instance:GetFullName(), {
                        property = property,
                        from = tostring(oldVal),
                        to = tostring(newVal)
                    })
            end
        })
    end
end

-- Audio detection and protection
local function setupAudioProtection()
    if not SECURITY_CONFIG.audioSecurity.enforceVolumeCap then return end
    
    -- Function to check and adjust audio volume
    local function checkAudio(sound)
        if not sound or not sound:IsA("Sound") then return end
        
        -- Check volume against cap
        if sound.Volume > SECURITY_CONFIG.audioSecurity.maxVolume then
            local originalVolume = sound.Volume
            
            -- Cap the volume
            pcall(function()
                sound.Volume = SECURITY_CONFIG.audioSecurity.maxVolume
            end)
            
            -- Log if significantly loud
            if originalVolume > SECURITY_CONFIG.audioSecurity.maxVolume * 1.5 then
                logSecurity("WARNING", "Loud audio detected and capped", sound:GetFullName(), {
                    originalVolume = originalVolume,
                    newVolume = sound.Volume,
                    soundId = sound.SoundId
                })
            end
        end
        
        -- Monitor volume changes
        sound:GetPropertyChangedSignal("Volume"):Connect(function()
            if sound.Volume > SECURITY_CONFIG.audioSecurity.maxVolume then
                sound.Volume = SECURITY_CONFIG.audioSecurity.maxVolume
            end
        end)
    end
    
    -- Process existing sounds if enabled
    if SECURITY_CONFIG.audioSecurity.scanExistingOnStart then
        for _, sound in ipairs(game:GetDescendants()) do
            if sound:IsA("Sound") then
                checkAudio(sound)
            end
        end
    end
    
    -- Monitor for new sounds
    game.DescendantAdded:Connect(function(instance)
        if instance:IsA("Sound") then
            checkAudio(instance)
        end
    end)
    
    logSecurity("INFO", "Audio protection system initialized", nil, {
        maxVolume = SECURITY_CONFIG.audioSecurity.maxVolume,
        earRapeBlocking = SECURITY_CONFIG.audioSecurity.blockEarRape
    })
end

-- GUI detection and protection
local function setupGuiProtection()
    if not SECURITY_CONFIG.guiSecurity.monitorPlayerGui then return end
    
    -- Function to monitor a player's GUI
    local function monitorPlayerGui(player)
        if not player or not player:IsA("Player") then return end
        
        -- Wait for PlayerGui
        local playerGui = player:FindFirstChild("PlayerGui")
        if not playerGui then
            player.ChildAdded:Connect(function(child)
                if child.Name == "PlayerGui" then
                    monitorPlayerGui(player) -- Recursive call when PlayerGui is added
                end
            end)
            return
        end
        
        -- Track known legitimate GUIs from StarterGui
        local knownGuis = {}
        local starterGui = game:GetService("StarterGui")
        for _, gui in ipairs(starterGui:GetChildren()) do
            knownGuis[gui.Name] = true
        end
        
        -- Monitor for new GUIs
        playerGui.ChildAdded:Connect(function(gui)
            if not knownGuis[gui.Name] then
                -- Log unknown GUI
                logSecurity("WARNING", "Unknown GUI added to player", player.Name, {
                    guiName = gui.Name,
                    guiType = gui.ClassName
                })
                
                -- Check for covering GUIs that might be exploit UIs
                if gui:IsA("ScreenGui") and SECURITY_CONFIG.guiSecurity.blockScreenCoveringGuis then
                    pcall(function()
                        -- Look for full screen frames that might cover the screen
                        for _, frame in ipairs(gui:GetDescendants()) do
                            if frame:IsA("Frame") and frame.Size.X.Scale >= 0.9 and frame.Size.Y.Scale >= 0.9 then
                                logSecurity("CRITICAL", "Screen-covering GUI detected and neutralized", player.Name, {
                                    guiName = gui.Name,
                                    frameName = frame.Name
                                })
                                
                                -- Make it transparent rather than destroying it
                                -- This preserves the GUI structure but makes it harmless
                                frame.BackgroundTransparency = 0.9
                            end
                        end
                    end)
                end
                
                -- Add to known GUIs to prevent duplicate notifications
                knownGuis[gui.Name] = true
            end
        end)
    end
    
    -- Set up player monitoring
    game:GetService("Players").PlayerAdded:Connect(monitorPlayerGui)
    for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
        monitorPlayerGui(player) -- Monitor existing players
    end
    
    logSecurity("INFO", "GUI protection system initialized", nil, {
        blockFullScreenGuis = SECURITY_CONFIG.guiSecurity.blockFullScreenGuis,
        monitorNewGuis = SECURITY_CONFIG.guiSecurity.logNewGuiAdditions
    })
end

-- Require function protection
local function setupRequireProtection()
    if not SECURITY_CONFIG.scriptSecurity.blockRequireCalls then return end
    
    -- Track all ModuleScripts
    local moduleRegistry = {}
    
    -- Function to scan a module script
    local function scanModule(moduleScript)
        if not moduleScript or not moduleScript:IsA("ModuleScript") then return end
        
        -- Register the module
        moduleRegistry[moduleScript:GetFullName()] = true
        
        -- Check module content for threats
        local isThreatening, threats = scanScriptForThreats(moduleScript)
        if isThreatening then
            logSecurity("CRITICAL", "Malicious ModuleScript detected", moduleScript:GetFullName(), {
                threats = threats,
                action = "Module neutralized"
            })
            
            -- Optionally make module return harmless data instead of destroying it
            -- This ensures anything requiring it doesn't error but gets safe data
            pcall(function()
                moduleScript.Source = "return { _SECURITY_REPLACED = true, _REASON = 'Security violation detected' }"
            end)
        end
    end
    
    -- Scan existing ModuleScripts
    for _, module in ipairs(game:GetDescendants()) do
        if module:IsA("ModuleScript") then
            scanModule(module)
        end
    end
    
    -- Monitor for new ModuleScripts
    game.DescendantAdded:Connect(function(instance)
        if instance:IsA("ModuleScript") then
            scanModule(instance)
        end
    end)
    
    logSecurity("INFO", "require() protection system initialized", nil, {
        moduleScriptsChecked = #game:GetDescendants():Filter(function(i) return i:IsA("ModuleScript") end)
    })
end

-- Advanced detection of explorer tampering
local function detectExplorerTampering()
    -- This is a simplified version of detection
    -- In a real implementation, this would use more advanced techniques
    
    -- Monitor for plugin-related events
    if game:GetService("RunService"):IsStudio() then
        -- In Studio, we can monitor plugin activity
        pcall(function()
            -- Use safer detection methods that don't rely on PluginManager
            -- Monitor property changes on core services that might indicate tampering
            for _, serviceName in ipairs({"Workspace", "StarterGui", "ReplicatedStorage"}) do
                local service = game:GetService(serviceName)
                service.Changed:Connect(function(property)
                    -- Log potential explorer tampering
                    logSecurity("INFO", "Studio explorer activity detected", serviceName, {
                        property = property
                    })
                end)
            end
            
            -- Alternative detection for plugins without using PluginManager directly
            -- This is a safe fallback that will work in all environments
            RunService.Heartbeat:Connect(function()
                -- Periodic check for suspicious activity in Studio
                -- This is just a placeholder for actual detection logic
                if workspace:FindFirstChild("__PLUGIN_INDICATOR__") then
                    logSecurity("INFO", "Plugin activity detected", "Studio", {})
                end
            end)
        end)
    end
    
    -- Implement additional detection methods
    -- These would be more sophisticated in a real implementation
end

-- Function to monitor script creation
local function setupScriptMonitoring()
    -- Monitor the creation of any scripts in the game
    game.DescendantAdded:Connect(function(instance)
        if instance:IsA("Script") or instance:IsA("LocalScript") or instance:IsA("ModuleScript") then
            -- Check the script for threats
            local isThreateningScript, threats = scanScriptForThreats(instance)
            if isThreateningScript then
                logSecurity("CRITICAL", "Malicious script detected", instance:GetFullName(), {
                    threats = threats
                })
                
                -- Try to automatically delete the malicious script if enabled
                handleMaliciousScript(instance, threats)
            end
        end
    end)
    
    -- Scan existing scripts if enabled
    if SECURITY_CONFIG.scriptSecurity.scanExistingOnStart then
        logSecurity("INFO", "Scanning existing scripts for threats", nil, {})
        
        local suspiciousScripts = 0
        for _, script in ipairs(game:GetDescendants()) do
            if script:IsA("Script") or script:IsA("LocalScript") or script:IsA("ModuleScript") then
                local isThreateningScript, threats = scanScriptForThreats(script)
                if isThreateningScript then
                    suspiciousScripts = suspiciousScripts + 1
                    -- Don't auto-delete existing scripts for safety, but report them
                    logSecurity("WARNING", "Existing suspicious script found", script:GetFullName(), {
                        threats = threats
                    })
                end
            end
        end
        
        logSecurity("INFO", "Script scan completed", nil, {
            suspiciousCount = suspiciousScripts,
            totalScanned = #game:GetDescendants():Filter(function(i) 
                return i:IsA("Script") or i:IsA("LocalScript") or i:IsA("ModuleScript")
            end)
        })
    end
end

-- Function to detect modification attempts
local function monitorSecurityStatus()
    -- Create a loop that periodically checks the game state
    -- This would run on the server to detect unusual activity
    
    local function checkGameStatus()
        -- Check for unauthorized server scripts
        for _, script in pairs(ServerScriptService:GetDescendants()) do
            if script:IsA("Script") then
                -- Verify script integrity
                local isThreatening, threats = scanScriptForThreats(script)
                if isThreatening then
                    handleMaliciousScript(script, threats)
                end
            end
        end
    end
    
    -- Run initial check
    checkGameStatus()
    
    -- Set up periodic monitoring
    if RunService:IsServer() then
        -- Create a periodic check on the server
        local heartbeatConnection
        heartbeatConnection = RunService.Heartbeat:Connect(function()
            -- Only check periodically, not every frame
            if os.time() % SECURITY_CONFIG.monitorFrequency == 0 then
                checkGameStatus()
            end
        end)
        
        -- Provide a way to disconnect if needed
        return function()
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
            end
        end
    end
    
    return function() end  -- Empty cleanup function if not on server
end

-- Return security interface for main script to use
return {
    scanScript = scanScriptForThreats,
    protectInstance = deepProtectInstance,
    getConfig = function() return SECURITY_CONFIG end,
    setConfig = function(newConfig)
        -- Update config but only allow from authenticated source
        for k, v in pairs(newConfig) do
            if SECURITY_CONFIG[k] ~= nil then
                SECURITY_CONFIG[k] = v
            end
        end
    end,
    initialize = function()
        protectCriticalServices()
        detectExplorerTampering()
        setupAudioProtection()
        setupGuiProtection()
        setupRequireProtection()
        setupScriptMonitoring()
        return monitorSecurityStatus()
    end,
    isUserWhitelisted = function(username)
        return SECURITY_CONFIG.scriptSecurity.whitelistedCreators[username] == true
    end,
    addWhitelistedUser = function(username)
        if type(username) == "string" then
            SECURITY_CONFIG.scriptSecurity.whitelistedCreators[username] = true
            return true
        end
        return false
    end,
    getSecurityStats = function()
        return {
            configVersion = "2.0",
            maliciousPatternsCount = #SECURITY_CONFIG.maliciousPatterns,
            protectedServicesCount = #SECURITY_CONFIG.protectedInstances,
            audioProtectionEnabled = SECURITY_CONFIG.audioSecurity.enforceVolumeCap,
            guiProtectionEnabled = SECURITY_CONFIG.guiSecurity.monitorPlayerGui,
            requireProtectionEnabled = SECURITY_CONFIG.scriptSecurity.blockRequireCalls,
            autoDeleteEnabled = SECURITY_CONFIG.scriptSecurity.autoDeleteMalicious,
            whitelistedUsers = SECURITY_CONFIG.scriptSecurity.whitelistedCreators
        }
    end
}
</pre>
</body>
</html>
